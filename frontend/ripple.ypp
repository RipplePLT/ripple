%{	
#include <cctype>
#include <cstdio>
#include <string>
#include <iostream>
#include "frontend/ast.h"
using namespace std;

extern int yylex();
void yyerror(const char *s) { printf("%s\n", s); }
//#define YYSTYPE std::string

void d(string m) {
//    cerr << m << endl;
}
%}


%union {
    BinaryExpression *binExpr;
    UnaryExpression *unExpr;
    ValueNode *val;
    int integer;
    std::string *string;
    double decimal;
    bool boolean;
}

/***************
    KEYWORDS 
***************/
%token <integer> IF
%token <integer> ELSE
%token <integer> FOR
%token <integer> WHILE
%token <integer> LINK
%token <integer> IMPORT
%token <integer> FINAL
%token <integer> RETURN
%token <integer> CONTINUE
%token <integer> BREAK

/***************
      TYPES 
***************/
%token <integer> TYPE
%token <integer> BOOL
%token <integer> BYTE
%token <integer> INT
%token <integer> FLOAT
%token <integer> STRING 
%token <integer> DATASET
%token <integer> VOID

/***************
    VARIABLES 
***************/
%token <integer> ID
%token <integer> INTEGER
%token <decimal> FLOAT_LIT 
%token <string>  LITERAL 
%token <boolean> TRUE
%token <boolean> FALSE

/*****************
    SEPARATORS
*****************/
%token tSEMI
%token tCOMMA
%token tL_PAREN
%token tR_PAREN
%token tL_BRACKET
%token tR_BRACKET
%token tL_CURLY
%token tR_CURLY
%type <val> unit value
%type <unExpr> unary_expression
%type <binExpr> exp_expression mult_expression add_expression rel_expression eq_expression and_expression or_expression expression


%left tEQ
%left tNE

%left tLT
%left tLE
%left tGT
%left tGE

%left AND
%left OR

%left tPLUS
%left tMINUS
%left tTIMES
%left tDIV
%left tMOD
%left tFLDIV

%right tEXP
%right tSIZE
%right NOT 

%right tASSIGN
%right tACCESS

%%

/* TEMPORARY; ONLY HERE TO TEST EXPRESSIONS */
program : program expression tSEMI { d("success"); } 
        |
        ;

args : args tCOMMA expression
     | expression
     ;

expression : or_expression             { $$ = $1;  d("exp");}
           | value tASSIGN or_expression  
           ;

or_expression : and_expression                  { $$ = new BinaryExpression($1); d("or_exp");}
              | or_expression OR and_expression { $$ = new BinaryExpression($1, "or", $3); }
              ;

and_expression : eq_expression                      { $$ = new BinaryExpression($1); d("and_exp");}
               | and_expression AND eq_expression   { $$ = new BinaryExpression($1, "and", $3); }
               ;

eq_expression : rel_expression                      { $$ = new BinaryExpression($1); d("eq_exp");}
              | eq_expression tEQ rel_expression   { $$ = new BinaryExpression($1, "==", $3); }
              | eq_expression tNE rel_expression   { $$ = new BinaryExpression($1, "!=", $3); }
              ;

rel_expression : add_expression                     { $$ = new BinaryExpression($1); d("rel_exp"); }
               | rel_expression tGT add_expression  { $$ = new BinaryExpression($1, ">", $3); }
               | rel_expression tLT add_expression  { $$ = new BinaryExpression($1, "<", $3); }
               | rel_expression tGE add_expression { $$ = new BinaryExpression($1, ">=", $3); }
               | rel_expression tLE add_expression { $$ = new BinaryExpression($1, "<=", $3); }
               ;

add_expression : mult_expression                    { $$ = new BinaryExpression($1); d("add_exp");}
               | add_expression tPLUS mult_expression { $$ = new BinaryExpression($1, "+", $3); d("final");}
               | add_expression tMINUS mult_expression { $$ = new BinaryExpression($1, "-", $3);  d("add -"); }
               ;

mult_expression : exp_expression                        { $$ = new BinaryExpression($1); d("mult_exp");}
                | mult_expression tTIMES exp_expression    { $$ = new BinaryExpression($1, "*", $3);  d("mult *"); }
                | mult_expression tDIV exp_expression    { $$ = new BinaryExpression($1, "/", $3);  d("mult /"); }
                | mult_expression tFLDIV exp_expression   { $$ = new BinaryExpression($1, "//", $3);  d("mult //"); }
                | mult_expression tMOD exp_expression    { $$ = new BinaryExpression($1, "%", $3);  d("mult %"); }
                ;

exp_expression : unary_expression                       { $$ = new BinaryExpression($1); d("exp_expression");}
               | exp_expression tEXP unary_expression    { $$ = new BinaryExpression($1, "^", $3);  d("exp^"); }
               ;

unary_expression : value                    { $$ = new UnaryExpression($1); d("unary_expression");};	
                 | tMINUS unary_expression     { $$ = new UnaryExpression($2, "-");  d("un -"); }
                 | tSIZE unary_expression     { $$ = new UnaryExpression($2, "@");  d("un @"); }
                 | tL_PAREN TYPE tR_PAREN unary_expression
                 | NOT unary_expression     { $$ = new UnaryExpression($2, "not");  d("un not"); }
                 ;

value : unit            { $$ = $1; d("value");}
      | function_call
      | array_access
      | dataset_access
      ;

function_call : ID tL_PAREN args tR_PAREN
	      | ID tL_PAREN tR_PAREN
	      ;

array_access : value tL_BRACKET expression tR_BRACKET
             ;

dataset_access : value tACCESS ID
               ;

unit  : ID				              { d("ID"); }
      | INTEGER                 { $$ = new ValueNode($1); d("INT");}	
      | FLOAT_LIT               { $$ = new ValueNode($1);  d("FLOAT"); }
      | STRING                  { $$ = new ValueNode($1);  d("STRING"); }
      | TRUE				    { $$ = new ValueNode($1);  d("true"); }
      | FALSE				    { $$ = new ValueNode($1);  d("false"); }
      | tL_PAREN expression tR_PAREN
      ;

%%

int main(void) {
    yyparse();
    return 0;
}
