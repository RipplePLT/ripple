%{	
#include <cctype>
#include <cstdio>
#include <string>
#include <iostream>
#include "frontend/ast.h"
using namespace std;

extern int yylex();
void yyerror(const char *s) { printf("%s\n", s); }
//#define YYSTYPE std::string
%}


%union {
    BinaryExpression *binExpr;
    UnaryExpression *unExpr;
    ValueNode *val;
    int integer;
    std::string *string;
    double decimal;
    bool boolean;
}

/***************
    KEYWORDS 
***************/
%token <integer> IF
%token <integer> ELSE
%token <integer> FOR
%token <integer> WHILE
%token <integer> LINK
%token <integer> IMPORT
%token <integer> FINAL
%token <integer> RETURN
%token <integer> CONTINUE
%token <integer> BREAK

/***************
      TYPES 
***************/
%token <integer> TYPE
%token <integer> BOOL
%token <integer> BYTE
%token <integer> INT
%token <integer> FLOAT
%token <integer> STRING 
%token <integer> DATASET
%token <integer> VOID

/***************
    VARIABLES 
***************/
%token <integer> ID
%token <integer> INTEGER
%token <decimal> FLOAT_LIT 
%token <string>  LITERAL 
%token <boolean> TRUE
%token <boolean> FALSE

%type <val> unit value
%type <unExpr> unary_expression
%type <binExpr> exp_expression mult_expression add_expression rel_expression eq_expression and_expression or_expression expression

%left "=="
%left "!="

%left "<"
%left "<="
%left ">"
%left ">="

%left AND
%left OR

%left "+" 
%left "-" 
%left "*" 
%left "/" 
%left "%" 
%left "//"

%right "^" 
%right "@"
%right NOT 

%right "="

%%

/* TEMPORARY; ONLY HERE TO TEST EXPRESSIONS */
program : program expression ";" { cout << "success" << endl; } 
        |
        ;

args : args "," expression
     | expression
     ;

expression : or_expression             { $$ = $1;  }
           | value "=" or_expression  
           ;

or_expression : and_expression                  { $$ = new BinaryExpression($1); }
              | or_expression OR and_expression { $$ = new BinaryExpression($1, "or", $3); }
              ;

and_expression : eq_expression                      { $$ = new BinaryExpression($1); }
               | and_expression AND eq_expression   { $$ = new BinaryExpression($1, "and", $3); }
               ;

eq_expression : rel_expression                      { $$ = new BinaryExpression($1); }
              | eq_expression "==" rel_expression   { $$ = new BinaryExpression($1, "==", $3); }
              | eq_expression "!=" rel_expression   { $$ = new BinaryExpression($1, "!=", $3); }
              ;

rel_expression : add_expression                     { $$ = new BinaryExpression($1); }
               | rel_expression ">" add_expression  { $$ = new BinaryExpression($1, ">", $3); }
               | rel_expression "<" add_expression  { $$ = new BinaryExpression($1, "<", $3); }
               | rel_expression ">=" add_expression { $$ = new BinaryExpression($1, ">=", $3); }
               | rel_expression "<=" add_expression { $$ = new BinaryExpression($1, "<=", $3); }
               ;

add_expression : mult_expression                    { $$ = new BinaryExpression($1); }
               | add_expression "+" mult_expression { $$ = new BinaryExpression($1, "+", $3); }
               | add_expression "-" mult_expression { $$ = new BinaryExpression($1, "-", $3); }
               ;

mult_expression : exp_expression                        { $$ = new BinaryExpression($1); }
                | mult_expression "*" exp_expression    { $$ = new BinaryExpression($1, "*", $3); }
                | mult_expression "/" exp_expression    { $$ = new BinaryExpression($1, "/", $3); }
                | mult_expression "//" exp_expression   { $$ = new BinaryExpression($1, "//", $3); }
                | mult_expression "%" exp_expression    { $$ = new BinaryExpression($1, "%", $3); }
                ;

exp_expression : unary_expression                       { $$ = new BinaryExpression($1); }
               | exp_expression "^" unary_expression    { $$ = new BinaryExpression($1, "^", $3); }
               ;

unary_expression : value                    { $$ = new UnaryExpression($1); };	
                 | "-" unary_expression     { $$ = new UnaryExpression($2, "-"); }
                 | "@" unary_expression     { $$ = new UnaryExpression($2, "@"); }
                 | "(" TYPE ")" unary_expression
                 | NOT unary_expression     { $$ = new UnaryExpression($2, "not"); }
                 ;

value : unit            { $$ = $1; }
      | function_call
      | array_access
      | dataset_access
      ;

function_call : ID "(" args ")"
	      | ID "()"
	      ;

array_access : value "[" expression "]"
             ;

dataset_access : value "." ID
               ;

unit  : ID				 
      | INTEGER                 { $$ = new ValueNode($1); }	
      | FLOAT_LIT               { $$ = new ValueNode($1); }
      | STRING                  { $$ = new ValueNode($1); }
      | TRUE				    { $$ = new ValueNode($1); }
      | FALSE				    { $$ = new ValueNode($1); }
      | "(" expression ")"
      ;

%%

int main(void) {
    yyparse();
    return 0;
}
