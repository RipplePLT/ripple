%{	
#include <cctype>
#include <cstdio>
#include <string>
#include <iostream>
#include "frontend/ast.h"
#define DEBUG
using namespace std;

extern int yylex();
void yyerror(const char *s) { printf("%s\n", s); }
//#define YYSTYPE std::string

void d(string m) {
#ifdef DEBUG
    cerr << m << endl;
#endif
}
%}


%union {
    StatementListNode *stmt_list;
    StatementNode *stmt;
    DeclarativeStatementNode *dec_stmt;
    ConditionalStatementNode *cond_stmt;

    ExpressionNode *expr;
    BinaryExpressionNode *bin_expr;
    UnaryExpressionNode *un_expr;
    
    ArrayAccessNode *arr_acc;
    DatasetAccessNode *ds_acc;
    FunctionCallNode *fn_call;
    LiteralNode *lit;
    ValueNode *val;
    ArgsNode *args;
    IDNode *id;
    
    int integer;
    string *string;
    double decimal;
    bool boolean;
}

/***************
    KEYWORDS 
***************/
%token <integer> IF
%token <integer> ELSE
%token <integer> FOR
%token <integer> WHILE
%token <integer> LINK
%token <integer> IMPORT
%token <integer> FINAL
%token <integer> RETURN
%token <integer> CONTINUE
%token <integer> BREAK

/***************
      TYPES 
***************/
%token <integer> TYPE
%token <integer> BOOL
%token <integer> BYTE
%token <integer> INT
%token <integer> FLOAT
%token <integer> STRING 
%token <integer> DATASET
%token <integer> VOID

/***************
    VARIABLES 
***************/
%token <id> ID
%token <integer> INTEGER
%token <decimal> FLOAT_LIT 
%token <string>  LITERAL 
%token <boolean> TRUE
%token <boolean> FALSE

/*****************
    SEPARATORS
*****************/
%token tSEMI
%token tCOMMA
%token tL_PAREN
%token tR_PAREN
%token tL_BRACKET
%token tR_BRACKET
%token tL_CURLY
%token tR_CURLY
%type <lit> literal
%type <un_expr> unary_expression
%type <bin_expr> exp_expression mult_expression add_expression rel_expression eq_expression and_expression or_expression
%type <expr> expression
%type <arr_acc> array_access
%type <fn_call> function_call
%type <ds_acc> dataset_access
%type <val> value
%type <args> args;
%type <dec_stmt> declarative_statement
%type <stmt> statement
%type <stmt_list> statement_list statement_block else_statement
%type <cond_stmt> conditional_statement

%left tEQ
%left tNE

%left tLT
%left tLE
%left tGT
%left tGE

%left AND
%left OR

%left tPLUS
%left tMINUS
%left tTIMES
%left tDIV
%left tMOD
%left tFLDIV

%right tEXP
%right tSIZE
%right NOT 

%right tASSIGN
%right tACCESS

%%

statement_block : tL_CURLY statement_list tR_CURLY { $$ = $2; }
                ;

statement_list : statement_list statement       { $1->push_statement($2); d("statement_block - stmt"); }
                | statement                     { $$ = new StatementListNode(); $$->push_statement($1); d("statement_block - curly_statement_block"); }
                | 
                ;

statement : declarative_statement               { $$ = new StatementNode($1); d("statement - declarative"); }
          | conditional_statement               { $$ = new StatementNode($1); d("statement - conditional"); }
          ;

declarative_statement : TYPE expression tSEMI   { $$ = new DeclarativeStatementNode(*yylval.string, $2); d("declarative statement -  type expr"); }
                      | expression tSEMI        { $$ = new DeclarativeStatementNode($1); d("declarative statement - expr"); }
                      ;

conditional_statement : IF tL_PAREN expression tR_PAREN statement_block else_statement  { $$ = new ConditionalStatementNode($3, $5, $6); }
                        ;

else_statement : ELSE statement_block   { $$ = $2; }
                |                       { $$ = NULL; }
                ;

expression : or_expression             { $$ = new ExpressionNode($1);  d("expression"); }
           | value tASSIGN or_expression { $$ = new ExpressionNode($3, $1); d("expression assign"); }
           ;

or_expression : and_expression                  { $$ = new BinaryExpressionNode($1); d("or_expression"); }
              | or_expression OR and_expression { $$ = new BinaryExpressionNode($1, "or", $3); d("or_expression OR"); }
              ;

and_expression : eq_expression                      { $$ = new BinaryExpressionNode($1); d("and_expression"); }
               | and_expression AND eq_expression   { $$ = new BinaryExpressionNode($1, "and", $3); d("and_expression AND"); }
               ;

eq_expression : rel_expression                      { $$ = new BinaryExpressionNode($1); d("eq_expression"); }
              | eq_expression tEQ rel_expression   { $$ = new BinaryExpressionNode($1, "==", $3); d("eq_expression =="); }
              | eq_expression tNE rel_expression   { $$ = new BinaryExpressionNode($1, "!=", $3); d("eq_expression !="); }
              ;

rel_expression : add_expression                     { $$ = new BinaryExpressionNode($1); d("rel_expression"); }
               | rel_expression tGT add_expression  { $$ = new BinaryExpressionNode($1, ">", $3); d("rel_expression >"); }
               | rel_expression tLT add_expression  { $$ = new BinaryExpressionNode($1, "<", $3); d("rel_expression <"); }
               | rel_expression tGE add_expression { $$ = new BinaryExpressionNode($1, ">=", $3); d("rel_expression >="); }
               | rel_expression tLE add_expression { $$ = new BinaryExpressionNode($1, "<=", $3); d("rel_expression <="); }
               ;

add_expression : mult_expression                    { $$ = new BinaryExpressionNode($1); d("add_expression");}
               | add_expression tPLUS mult_expression { $$ = new BinaryExpressionNode($1, "+", $3); d("add_expression +");}
               | add_expression tMINUS mult_expression { $$ = new BinaryExpressionNode($1, "-", $3);  d("add_expression -"); }
               ;

mult_expression : exp_expression                        { $$ = new BinaryExpressionNode($1); d("mult_expression");}
                | mult_expression tTIMES exp_expression    { $$ = new BinaryExpressionNode($1, "*", $3);  d("mult_expression *"); }
                | mult_expression tDIV exp_expression    { $$ = new BinaryExpressionNode($1, "/", $3);  d("mult_expression /"); }
                | mult_expression tFLDIV exp_expression   { $$ = new BinaryExpressionNode($1, "//", $3);  d("mult_expression //"); }
                | mult_expression tMOD exp_expression    { $$ = new BinaryExpressionNode($1, "%", $3);  d("mult_expression %"); }
                ;

exp_expression : unary_expression                       { $$ = new BinaryExpressionNode($1); d("exp_expression");}
               | exp_expression tEXP unary_expression    { $$ = new BinaryExpressionNode($1, "^", $3);  d("exp expression ^"); }
               ;

unary_expression : value                    { $$ = new UnaryExpressionNode($1); d("unary_expression");};	
                 | tMINUS unary_expression     { $$ = new UnaryExpressionNode($2, "-");  d("unary_expression -"); }
                 | tSIZE unary_expression     { $$ = new UnaryExpressionNode($2, "@");  d("unary_expression @"); }
                 | tL_PAREN TYPE tR_PAREN unary_expression
                 | NOT unary_expression     { $$ = new UnaryExpressionNode($2, "not");  d("unary_expression not"); }
                 ;

value : literal            { $$ = new ValueNode($1); d("value - literal"); }
      | function_call      { $$ = new ValueNode($1); d("value - function_call"); }
      | array_access       { $$ = new ValueNode($1); d("value - array_access"); }
      | dataset_access     { $$ = new ValueNode($1); d("value - dataset_access"); }
      | ID                 { $$ = new ValueNode($1); d("value - ID"); cout << $1 <<endl;}
      | tL_PAREN expression tR_PAREN { $$ = new ValueNode($2); d("value - expression"); }
      ;

args : args tCOMMA expression   { $1->add_arg($3); d("arg added - 1");}
     | expression               { $$ = new ArgsNode(); $$->add_arg($1); d("arg added");}
     |                          { $$ = new ArgsNode(); }
     ;

function_call : ID tL_PAREN args tR_PAREN { $$ = new FunctionCallNode($1, $3); d("function call"); }
	          ;

array_access : value tL_BRACKET expression tR_BRACKET { $$ = new ArrayAccessNode($1, $3); d("Array access");}
             ;

dataset_access : value tACCESS ID { $$ = new DatasetAccessNode($1, $3); d("Dataset access");}
               ;

literal : INTEGER                 { $$ = new LiteralNode($1); d("literal - INT");}	
        | FLOAT_LIT               { $$ = new LiteralNode($1); d("literal - FLOAT");}
        | STRING                  { $$ = new LiteralNode($1);  d("literal - STRING"); }
        | TRUE				            { $$ = new LiteralNode($1);  d("literal - true"); }
        | FALSE				            { $$ = new LiteralNode($1);  d("literal - false"); }
        ;

%%

int main(void) {
    yyparse();
    return 0;
}
