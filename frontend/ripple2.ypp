%{	
#include <cctype>
#include <cstdio>
#include <string>
#include <iostream>
#include "frontend/symbol_table/symbol_table.h"
#include "frontend/ast.h"
#include "misc/debug_tools.h"
using namespace std;

extern int yylex();
void yyerror(const char *s) { printf("%s\n", s); }

extern SymbolTable sym_table;

e_type func_type;

extern int line_no;
extern string cpp_code;
extern e_type last_type;
%}


%union {
    Ripple::AST::LiteralNode *literal_node;
    Ripple::AST::ValueNode *value_node;
    Ripple::AST::UnaryExpressionNode *unary_expression_node;
    Ripple::AST::BinaryExpressionNode *binary_expression_node;

    int integer;
    string *string;
    double decimal;
    bool boolean;
}

/***************
    KEYWORDS 
***************/
%token <integer> IF
%token <integer> ELSE
%token <integer> FOR
%token <integer> WHILE
%token <integer> LINK
%token <integer> IMPORT
%token <integer> FINAL
%token <integer> RETURN
%token <integer> CONTINUE
%token <integer> BREAK
%token <integer> THEN
%token <integer> STOP

/***************
      TYPES 
***************/
%token <integer> TYPE
%token <integer> BOOL
%token <integer> INT
%token <integer> FLOAT
%token <integer> STRING 
%token <integer> DATASET
%token <integer> VOID
%token <integer> tSTREAM_READER

/***************
    IDIABLES 
***************/
%token <string> ID
%token <integer> INTEGER
%token <decimal> FLOAT_LIT 
%token <string>  STRING_LITERAL 
%token <boolean> TRUE
%token <boolean> FALSE

/*****************
    SEPARATORS
*****************/
%token tSEMI
%token tARROW
%token tCOMMA
%token tL_PAREN
%token tR_PAREN
%token tL_BRACKET
%token tR_BRACKET
%token tL_CURLY
%token tR_CURLY

/*************************
    TYPE DECLARATIONS
*************************/
%type <value_node> value
%type <literal_node> literal
%type <unary_expression_node> unary_expression
%type <binary_expression_node> exp_expression mult_expression add_expression rel_expression eq_expression and_expression or_expression expression

/*********************
    ASSOCIATIVITY
*********************/
%left tEQ
%left tNE

%left tLT
%left tLE
%left tGT
%left tGE

%left AND
%left OR

%left tPLUS
%left tMINUS
%left tTIMES
%left tDIV
%left tMOD
%left tFLDIV

%right tEXP
%right tSIZE
%right NOT 

%right tASSIGN
%right tACCESS

%%

expression : or_expression 							{ $$ = $1; d("expression"); }

or_expression : and_expression						{ $$ = $1; d("or_expression"); }
			  | or_expression OR and_expression		{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_or, $3); d("or_expression or"); }

and_expression : eq_expression						{ $$ = $1; d("and_expression"); }
			   | and_expression AND eq_expression	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_and, $3); d("and_expression and"); }

eq_expression : rel_expression 						{ $$ = $1; d("eq_expression"); }
			  | eq_expression tEQ rel_expression 	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_equals, $3); d("eq_expression =="); }
			  | eq_expression tNE rel_expression	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_not_equals, $3); d("eq_expression !="); }
			  ;

rel_expression : add_expression						{ $$ = $1; d("rel_expression"); }
			   | rel_expression tGT add_expression	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_gt, $3); d("rel_expression >"); }
			   | rel_expression tLT add_expression  { $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_lt, $3); d("rel_expression <"); }
			   | rel_expression tGE add_expression	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_ge, $3); d("rel_expression >="); }
			   | rel_expression tLE add_expression	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_le, $3); d("rel_expression <="); }
			   ;

add_expression : mult_expression 						{ $$ = $1; d("add_expression"); }
			   | add_expression tPLUS mult_expression	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_plus, $3); d("add_expression +"); }
			   | add_expression tMINUS mult_expression	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_minus, $3); d("add_expression -"); }

mult_expression : exp_expression 						    { $$ = $1; d("mult_expression"); }
				| mult_expression tTIMES exp_expression 	{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_times, $3); d("mult_expression *"); }
				| mult_expression tDIV exp_expression		{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_divide, $3); d("mult_expression /"); }
				| mult_expression tFLDIV exp_expression		{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_fl_divide, $3); d("mult_expression //"); }
				| mult_expression tMOD exp_expression		{ $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_modulus, $3); d("mult_expression %"); }

exp_expression : unary_expression                     { $$ = new Ripple::AST::BinaryExpressionNode($1); d("exp_expression"); }
               | exp_expression tEXP unary_expression { $$ = new Ripple::AST::BinaryExpressionNode($1, Ripple::AST::binary_op_exponentiation, new Ripple::AST::BinaryExpressionNode($3)); d("exp_expression ^"); }

unary_expression : value                       { $$ = new Ripple::AST::UnaryExpressionNode($1); d("unary_expression");}
                 | tMINUS unary_expression     { $$ = new Ripple::AST::UnaryExpressionNode(Ripple::AST::unary_op_minus, $2);  d("unary_expression -"); }
                 | tSIZE unary_expression      { $$ = new Ripple::AST::UnaryExpressionNode(Ripple::AST::unary_op_size_of, $2);  d("unary_expression @"); }
                 | NOT unary_expression        { $$ = new Ripple::AST::UnaryExpressionNode(Ripple::AST::unary_op_not, $2);  d("unary_expression not"); }
                 ;

value : literal { $$ = new Ripple::AST::ValueNode($1); d("value - literal"); }

literal : INTEGER             { $$ = new Ripple::AST::LiteralNode($1); d("literal - INT"); }	
        | FLOAT_LIT           { $$ = new Ripple::AST::LiteralNode($1); d("literal - FLOAT");}
        | STRING_LITERAL      { $$ = new Ripple::AST::LiteralNode($1); d("literal - STRING"); }
        | TRUE				  { $$ = new Ripple::AST::LiteralNode($1); d("literal - true"); }
        | FALSE				  { $$ = new Ripple::AST::LiteralNode($1); d("literal - false"); }  
        ;

%%
